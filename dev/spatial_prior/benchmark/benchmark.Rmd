---
title: "BYM2 Benchmark"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  out.width = "100%"
)
```

### Build a linear predictor and simulate data

The data simulation mirrors the Stan model structure used for fitting. Each observation \(i=1,\dots,N\) has a binomial outcome
\[
y_i \sim \mathrm{Binomial}\!\left(n_i,\; p_i\right),\qquad
\text{with}\;\; \mathrm{logit}(p_n)=\eta_i.
\]
The linear predictor \(\eta_n\) combines fixed effects and several varying effects:
\[
\eta_n
= \beta_0 \;+\; \mathbf{x}_n^\top\boldsymbol\beta
\;+\; a^{(\mathrm{race})}_{J_{\mathrm{race}}[i]}
\;+\; a^{(\mathrm{age}) }_{J_{\mathrm{age}} [i]}
\;+\; a^{(\mathrm{time})}_{J_{\mathrm{time}}[i]}
\;+\; a^{(\mathrm{zip}) }_{J_{\mathrm{zip}} [i]}.
\]
Here \(\beta_0\) is the global intercept and \(\mathbf{x}_n\in\mathbb{R}^K\) is a vector of observed covariates; \(\boldsymbol\beta\) are the corresponding coefficients. The indices \(J_{\mathrm{race}}[i]\), \(J_{\mathrm{age}}[i]\), \(J_{\mathrm{time}}[i]\), and \(J_{\mathrm{zip}}[i]\) select the group-level effect for observation \(i\).

For the non-spatial groups, the simulator uses independent Gaussian intercepts written in **non-centered** form:
\[
\begin{aligned}
\mathbf{a}^{(\mathrm{race})} &= \lambda_{\mathrm{race}}\;\mathbf{z}^{(\mathrm{race})}, \quad &&\mathbf{z}^{(\mathrm{race})}\sim \mathcal{N}(\mathbf 0, I_{N_{\mathrm{race}}}),\\
\mathbf{a}^{(\mathrm{age})}  &= \lambda_{\mathrm{age}}\;\,\mathbf{z}^{(\mathrm{age})}, \quad &&\mathbf{z}^{(\mathrm{age})}\sim \mathcal{N}(\mathbf 0, I_{N_{\mathrm{age}}}),\\
\mathbf{a}^{(\mathrm{time})} &= \lambda_{\mathrm{time}}\;\mathbf{z}^{(\mathrm{time})}, \quad &&\mathbf{z}^{(\mathrm{time})}\sim \mathcal{N}(\mathbf 0, I_{N_{\mathrm{time}}}),
\end{aligned}
\]
with scale hyperparameters \(\lambda_{\bullet}\ge 0\). For the spatial effect over ZIP codes, the simulator uses an ICAR field (sum-to-zero) and the same scaling pattern:
\[
\begin{aligned}
\mathbf{a}^{(\mathrm{zip})} = \lambda_{\mathrm{zip}}\,\mathbf{z}^{(\mathrm{zip})}, \quad z_{j_{connected}}^{(\mathrm{zip})} \;=\; \Big(\sqrt{\rho/s}\;\phi \;+\; \sqrt{1-\rho}\;\theta_{j_{connectd}}\Big) \sigma, \quad z_{j_{isolated}}^{(\mathrm{zip})}\sim \mathcal{N}(\mathbf 0, 1)
\end{aligned}
\]

where:

- \(\phi_j\) is the ICAR component 
- \(\theta_j\) is the unstructured spatial effect
- \(s\) is the scaling factor computed from the neighborhood graph such that \(\operatorname{Var}(\phi_i) = 1\)
- \(\rho \in [0,1]\) controls the mixing between unstructured and structured components
- \(\sigma > 0\) is the overall standard deviation.

The following reparametrization shows exactly how the ICAR field is sampled:

\[
\boldsymbol\phi \;=\; R\,\eta, \quad R \;=\; U_+\,\Lambda_+^{-1/2}\in\mathbb R^{N_{zip}\times(N_{zip}-1)}, \quad \eta \sim \mathcal N(0,I_{N_{zip}-1}).
\]

where \(U_+\) and \(\Lambda_+\) constitute the eigenbasis of the sum-to-zero subspace.

\[
L^{+}=U_+\Lambda_+^{-1}U_+^\top,
\]

```{r include=FALSE}
source("simulation.R", local = TRUE)

suppressPackageStartupMessages({
  library(Matrix)
  library(cmdstanr)
  library(bayesplot)
  library(posterior)
  library(patchwork)
})

bayesplot::bayesplot_theme_set(
  bayesplot::theme_default() +
    ggplot2::theme(legend.position = "bottom")
)
```

## Model comparison for connected graphs

```{r}
seed <- sample(1e6, 1)
components <- list(c(5, 5))
stan_dir <- "/path/to/stan/files/"

sim_morris_sc <- run_sim(components = components, seed = seed, stan_path = paste0(stan_dir, "bym2_morris_sc.stan"))
sim_morris_mc <- run_sim(components = components, seed = seed, stan_path = paste0(stan_dir, "bym2_morris_mc.stan"))
sim_reparam   <- run_sim(components = components, seed = seed, stan_path = paste0(stan_dir, "bym2_reparam.stan"))
```


```{r}
print(sim_morris_sc$fit_summary)
print(sim_morris_mc$fit_summary)
print(sim_reparam$fit_summary)
```


```{r}
p_morris_sc <- sim_morris_sc$recovery$hist + sim_morris_sc$recovery$intervals
p_morris_sc
```

```{r}
p_morris_mc <- sim_morris_mc$recovery$hist + sim_morris_mc$recovery$intervals
p_morris_mc
```

```{r}
p_reparam <- sim_reparam$recovery$hist + sim_reparam$recovery$intervals
p_reparam
```

## Model comparison for disconnected graphs

```{r}
seed <- sample(1e6, 1)
components <- list(c(5, 5), c(5, 5), c(5, 5))
stan_dir <- "/Users/tntoan/Desktop/repos/shinymrp/dev/spatial_prior/benchmark/"

sim_morris_sc <- run_sim(components = components, seed = seed, stan_path = paste0(stan_dir, "bym2_morris_sc.stan"))
sim_morris_mc <- run_sim(components = components, seed = seed, stan_path = paste0(stan_dir, "bym2_morris_mc.stan"))
sim_reparam   <- run_sim(components = components, seed = seed, stan_path = paste0(stan_dir, "bym2_reparam.stan"))
```


```{r}
print(sim_morris_sc$fit_summary)
print(sim_morris_mc$fit_summary)
print(sim_reparam$fit_summary)
```


```{r}
p_morris_sc <- sim_morris_sc$recovery$hist + sim_morris_sc$recovery$intervals
p_morris_sc
```

```{r}
p_morris_mc <- sim_morris_mc$recovery$hist + sim_morris_mc$recovery$intervals
p_morris_mc
```

```{r}
p_reparam <- sim_reparam$recovery$hist + sim_reparam$recovery$intervals
p_reparam
```

## Computational complexity

```{r}
# Connect to Turbo
result_dir <- "/Volumes/sph-yajuan2/toan/spatial_prior/result/benchmark/"
results <- list(
  bym2_morris_sc = readRDS(paste0(result_dir, "sims_bym2_morris_sc.RDS")),
  bym2_morris_mc = readRDS(paste0(result_dir, "sims_bym2_morris_mc.RDS")),
  bym2_reparam   = readRDS(paste0(result_dir, "sims_bym2_reparam.RDS"))
)

plot_timing_by_nodes(results)
```


